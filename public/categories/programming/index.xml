<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programming on Gokul Nair</title>
    <link>//localhost:1313/categories/programming/</link>
    <description>Recent content in Programming on Gokul Nair</description>
    <generator>Hugo -- 0.147.3</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Aug 2025 11:30:03 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Real World Runs on Graphs!!ðŸ“ˆ : In the begining there was BROK!! (Part 3(final))</title>
      <link>//localhost:1313/posts/neo4j3/</link>
      <pubDate>Fri, 01 Aug 2025 11:30:03 +0000</pubDate>
      <guid>//localhost:1313/posts/neo4j3/</guid>
      <description>&lt;h2 id=&#34;a-quick-rewind&#34;&gt;A quick rewind!!&lt;/h2&gt;
&lt;p&gt;In the previous post, we implemented the follow functionality between users, comment posts, and also like functionality. Also we setup How to use Pinecone vector storage for indexing data for similarity search for our RAG. In this post, we will look into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Indexing the post data into our vector store.&lt;/li&gt;
&lt;li&gt;Will create the application with an LLM.&lt;/li&gt;
&lt;li&gt;create the ASK BROK functionality to know various details about the friends posts.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;large-language-model&#34;&gt;Large Language ModelðŸ¤–&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Large Language Models (LLMs)&lt;/strong&gt; like Mistralâ€™s &lt;em&gt;&lt;strong&gt;Open Mistral 7B&lt;/strong&gt;&lt;/em&gt; bring the power of natural language understanding and generation into your applications. Instead of manually writing complex rules for summarization, question answering, or sentiment analysis, you can simply provide a prompt and let the model handle the heavy lifting.
For example, if you want to summarize posts and analyze sentiment, a traditional approach would require separate steps:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Real World Runs on Graphs!!ðŸ“ˆ : Lets Make Users Social Again!! (Part 2)</title>
      <link>//localhost:1313/posts/neo4j2/</link>
      <pubDate>Fri, 01 Aug 2025 11:30:03 +0000</pubDate>
      <guid>//localhost:1313/posts/neo4j2/</guid>
      <description>In this post, weâ€™ll implement core social media features such as allowing users to follow others, create posts, and interact with them through likes and comments. Additionally, weâ€™ll set up a vector-based document storage system, which will serve as the foundation for integrating Retrieval-Augmented Generation (RAG) capabilities into our application.</description>
    </item>
    <item>
      <title>Real World Runs on Graphs!!ðŸ“ˆ : A Hands-On Intro to Neo4j (Part 1)</title>
      <link>//localhost:1313/posts/neo4j/</link>
      <pubDate>Thu, 17 Jul 2025 11:30:03 +0000</pubDate>
      <guid>//localhost:1313/posts/neo4j/</guid>
      <description>&lt;h2 id=&#34;graph-database-what-and-how&#34;&gt;Graph database what and how?&lt;/h2&gt;
&lt;p&gt;Recently at work, I had the opportunity to dive into a new product that deals with highly complex, hierarchical data schemasâ€”deeply interconnected across multiple levels of business domains. To put it simply: imagine an ETL process pulling structured data from physical documents and presenting that data differently for different teamsâ€”each with their own use cases and logic.&lt;/p&gt;
&lt;p&gt;Now, the fun (and frustration) really began when we start thinking about how to handle these transformations. Some were done using custom functions, others using Java reflection (yes..yes, you read it right, we use java reflectionðŸ™ƒ).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Supercharging Your PostgreSQL with Functions &amp; Stored Procedures</title>
      <link>//localhost:1313/posts/postgresfunction/</link>
      <pubDate>Sat, 15 Mar 2025 12:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/postgresfunction/</guid>
      <description>&lt;h1 id=&#34;tired-of-writing-the-same-sql-queries-over-and-over&#34;&gt;Tired of Writing the Same SQL Queries Over and Over?&lt;/h1&gt;
&lt;p&gt;Imagine you&amp;rsquo;re stuck in a loopâ€”executing the same SQL queries day in, day out. It feels a bit like Bill Murray in &lt;em&gt;Groundhog Day&lt;/em&gt;, doesn&amp;rsquo;t it?
&lt;img alt=&#34;Groundhog Day Gif&#34; loading=&#34;lazy&#34; src=&#34;https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExY2t2bWRoaTJqcGhweGJjajQ5eDdzbjRhcjQ1Z3lxOWhldDAzZG15ayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/S9crjCfQXC78ST61iv/giphy.gif&#34;&gt;
You find yourself copying and pasting nearly identical code across different parts of your application or repeatedly typing out similar commands during database maintenance.&lt;/p&gt;
&lt;p&gt;What if you could bundle these repetitive tasks into reusable, maintainable, and efficient code blocks inside your database? Good news: &lt;strong&gt;PostgreSQL&lt;/strong&gt; makes this possible with &lt;strong&gt;Functions&lt;/strong&gt; and &lt;strong&gt;Stored Procedures&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
